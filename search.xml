<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统-进程]]></title>
    <url>%2F2018%2F05%2F30%2Fos-process%2F</url>
    <content type="text"><![CDATA[进程进程是正在执行程序的实例，包括程序计算机，寄存器和变量。 从概念上说，每个进程都有自己的虚拟CPU，当然，实际的CPU是在进程之间来回切换。 实际上，只有一个物理程序计数器，所以个在每个程序运行时，它的逻辑程序计数器被装入到实际的程序计数器中。当该程序执行结束（暂停）时，物理程序计数器被装入到逻辑程序计数器中。 守护进程unix中，可以通过一个系统调用来创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用fork后，这两个进程（父进程和子进程）拥有相同的内存映像，同样的环境字符串和同样的打开文件 写时复制：进程的状态： 运行：cpu和条件都满足 阻塞：cpu满足，必要条件不满足 就绪：cpu不满足，必要条件满足 进程的实现： 有了进程模型，进程应该如何实现 为了实现进程模型，操作系统维护者一张（一个数据结构），即进程表。每个进程占用 一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针，内存 分配状况、所打开文件的状态、帐号和调度信息，以及其他在进程进行状态转换时所必 须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。 中断向量单个CPU如何维护多个顺序进程假设当一个磁盘中断发生时，用户进程正在运行，则中断硬件将程序计数器，程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这些是硬件完成的所有操作，然后软件，特别是中断服务例程就接管了一切剩余的工作。 线程为什么需要多线程1.有了多线程，并行实体拥有共享同一个地址空间和所有可有数据的能力。2.线程比进程更轻量级。3.IO密集的处理，使用多线程效率更高。 线程概念试图实现的是，共享一组资源的多个进程的执行能力，以便这些线程可以为完成某一个任务而共同工作。 进程：用某种方法将相关的资源集中在一起。进程有存放程序正文和数据以及其他的资源的地址空间。这些资源包括打开的文件，子进程，即将发生的定时器、信号处理程序、帐号信息等。线程：CPU调度的单位 线程堆栈线程的问题线程的过程子进程和父进程可以拥有相同的多线程吗，如果解决两者中线程的同步多线程中共享数据的同步 POSIX线程为了实现可移植的线程程序，IEEE定义了线程的标准。它定义的线程包叫作pthread.大部分UNIX系统都支持该标准。pthread_create 创建一个新的线程pthread_exit 结束调用的线程pthread_join 等待一个特定的线程退出pthread_yield 释放CPU来运行另外一个线程pthread_attr_init 创建并初始化一个线程的属性结构pthread_attr_destroy 删除一个线程的属性结构 代码演示：12345678910111213141516171819202122232425#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUMBER_OF_THREADS 10void *print_hello_world(void *tid)&#123; printf(&quot;hello world,Greeting form thread %d\n&quot;, tid); pthread_exit(NULL);&#125;int main(int args,char *argv[])&#123; pthread_t threads[NUMBER_OF_THREADS]; int status,i; for(i=0;i&lt;NUMBER_OF_THREADS; i++)&#123; printf(&quot;main here,creating thread %d\n&quot;,i); status = pthread_create(&amp;threads[i],NULL,print_hello_world,(void*)i); if(status!=0)&#123; printf(&quot;oops,pthread_create returned error code %d\n&quot;, status); &#125; &#125; exit(NULL);&#125; output:1234567891011121314151617181920main here,creating thread 0main here,creating thread 1hello world,Greeting form thread 0hello world,Greeting form thread 1main here,creating thread 2main here,creating thread 3hello world,Greeting form thread 2main here,creating thread 4hello world,Greeting form thread 3main here,creating thread 5hello world,Greeting form thread 4main here,creating thread 6hello world,Greeting form thread 5main here,creating thread 7hello world,Greeting form thread 6main here,creating thread 8hello world,Greeting form thread 7main here,creating thread 9hello world,Greeting form thread 8hello world,Greeting form thread 9]]></content>
  </entry>
  <entry>
    <title><![CDATA[git学习（二）]]></title>
    <url>%2F2018%2F05%2F22%2Fgit-learning-2%2F</url>
    <content type="text"><![CDATA[工作区和暂存区 git设计中有一些概念，了解这些概念对于深入学习git有很大的帮助。其中就有工作区和暂存区。 工作区 工作区就是创建的工作目录，这个目录下的所有文件都需要在git的管理之下。文件的创建，修改，删除都会被git记录。 暂存区 另外一个就是.git。这个称为版本库。版本库里存了很多东西，其中一个就是暂存区，所有的修改只有在提交到暂存区，才能被commit。12345678910位于分支 master要提交的变更： （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存） 修改： readme.txt未跟踪的文件: （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容） LICENSE git add 是将文件修改添加到暂存区 git commit 是将暂存区的所有内存提交到当前分支上 管理修改 上一节提到暂存区和工作区，git管理的是修改，而不是文件文件。为什么这样说呢，实验一下。 原readme.txt中的内容： 12git is a version control toolgit is so nice 第一次修改后的内容： 123git is a version control toolgit is so nicethis is first test 使用命令： 123456789101112xxx:~/workplace/demo$ git add readme.txtxxx:~/workplace/demo$ sudo git commit -m &quot;first&quot;[master e76954f] first1 file changed, 3 insertions(+)create mode 100644 readme.txtxxx:~/workplace/demo$ git status位于分支 master无文件要提交，干净的工作区xxx:~/workplace/demo$ cat readme.txtgit is a version control toolgit is so nicethis is first test 第二次修改的内容： 1234git is a version control toolgit is so nicethis is first testthis is second test 使用一下命令： 123456789 xxx:~/workplace/demo$ sudo git commit -m &quot;test&quot; 位于分支 master 尚未暂存以备提交的变更： （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容） （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动） 修改： readme.txt修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;） 由上面执行结果可以，第二次的修改并未被提交。 这也说明，只有将修改添加到暂存区才能进行后一步的提交。也能看出来git的确是对修改进行管理的，只有当修改添加到暂存区，才能把修改提交到分支上。文件已经被修改了，但是并不会被提交。 撤销修改 上一次讲过git的时光魔法，利用git reset可以让文件回到某一状态。但是针对的是提交后的。每次reset的标记也是commit id。 还有一种状况需要考虑，就是在修改没有commit之前，如何让文件恢复到某一时刻的状态。 git checkout就是专门负责则这个功能的。 1234567891011xxx:~/workplace/demo$ cat readme.txtgit is a version control toolgit is so nicethis is first testthis is second testthis is modify.xxx:~/workplace/demo$ git checkout readme.txtxxx:~/workplace/demo$ cat readme.txtgit is a version control toolgit is so nicethis is first test 可以从上面的命令清楚的看到，git checkout命令就相当于撤回键一样，可以让修该回到之前的一个状态。还有一个需要考虑的是，如果你的修改已经被提交，那么需要使用reset来回到上一个状态。 删除修改12345xxx:~/workplace/demo$ rm readme.txtxxx:~/workplace/demo$ sudo git commit -m &quot;delete&quot;[master 94de890] delete 1 file changed, 1 insertion(+)xxx:~/workplace/demo$]]></content>
  </entry>
  <entry>
    <title><![CDATA[git学习（一）]]></title>
    <url>%2F2018%2F05%2F22%2Fgit-learning-1%2F</url>
    <content type="text"><![CDATA[git是什么 git是一种版本控制工具，它的诞生是因为linux日益增长，代码合并依靠手工已经非常吃力。一开始linux也是用的其他的版本控制工具，但是后来提供版本控制的公司不再向linux社区提供支持，原因是因为这些大神太有创造性了，要修改他们的代码…balabala。最后linux的核心人物linus带领自己的小伙伴自己编写了一个版本控制工具：git.大神是怎么炼成的，心中充满了羡慕。 git能做什么 之前也没用到版本控制工具，只是在上一个项目中接触一点。但是也没系统的学习，刚好又要用到版本控制工具，就详细的学习一下。这么牛的东西不学习一下，怎么装x呢。 其实以前自己一个人做项目没有什么感受，但是几个人共同完成一个项目，问题就会层出不穷。比如jar包版本不同啊，这个可以通过项目管理工具maven来解决，什么是maven，有时间另写一遍来介绍它。还有一个比较大的问题，就是几个人的文件如何保持一致，一开始大家都是同一个文件没什么问题。但是任务一开始就是完全不同的场景了，A开始写他的功能，B开始写他的测试，C开始写他的页面。最后如何让大家的文件汇总起来呢，总不能一直复制粘帖吧，这样的效率是惨不忍睹的。git或者其他的版本控制工具可以帮助我们解决这个问题，具体怎么解决，一步一步学习吧。 git怎么用git的安装 在ubuntu环境： 1sudo apt-get install git 查看是否安装成功： 12git --versiongit version 2.7.4 git初次尝试 先创建一个文件夹作为git的工作目录， 1mkdir demo 什么意思呢?其实这个工作目录在git中有个专门的名称，叫做仓库，英文repository.它的意思这个目录下的所有文件都可以被git管理，每个的创建，修改，删除，git都能知道。git记录这些事情的发生，所以它也可以追踪到在整个文件的历史，并且它可以使某个文件回到某个历史节点。 刚刚只是创建了一个目录，还没有和git取得关联，这时候git并不能管理整个文件夹。 使用以下命令： 12cd demogit init 初始化空的 Git 仓库于 /home/xxx/workplace/demo/.git/ 这时候demo目录就变成了git可以管理的仓库了。 现在仓库下创建一个文件 touch readme.txt 在该文件里写入以下内容： 1234Git is a version control tool.Git is so nice.使用：git add readme.txt 可以将修改后的文件提交到暂存区内。12345位于分支 master初始提交要提交的变更： （使用 &quot;git rm --cached &lt;文件&gt;...&quot; 以取消暂存） 新文件： readme.txt 使用： 1git commit -m &quot;readme.txt&quot; 可以将暂存区的内容都提交到本地仓库中。（根提交） 435eb64] readme.txt12 1 file changed, 2 insertions(+)create mode 100644 readme.txt git的魔法–穿越时空 在表演git的魔法之前，我们先为文件做一个时间线，这样对一个文件才能完成穿越时空的操作。 1.在readme.txt中写入 1this is first add someting to readme.txt 然后输入命令 12git add readme.txtgit commit -m &apos;first add&apos; 2.在readme.txt中写入 1this is second add someting to readme.txt 然后输入命令 12git add readme.txtgit commit -m &apos;second add&apos; 使用git log 来查看历史线。1234567891011121314151617 commit fac4c988c2e9dc06074355cd137b51319ed65a7fAuthor: learner66 &lt;2952184251@qq.com&gt;Date: Tue May 22 19:01:07 2018 +0800 second addcommit b1c5887736de9909de4643ddd06a84b70ab50394Author: learner66 &lt;2952184251@qq.com&gt;Date: Tue May 22 19:00:17 2018 +0800 first addcommit 435eb64ac7e2b5f0d2f8153d940fc1d2ff92b89bAuthor: learner66 &lt;2952184251@qq.com&gt;Date: Tue May 22 18:50:46 2018 +0800 readme.txt readme.txt1234Git is a version control tool.Git is so nice.this is first add something to readme.this is second add something to readme. 穿越到过去 已经知道了这条历史线，git可以任意的穿越到过去的某个时间点。 回到过去有两种方法 git reset –hard HEAD^HEAD代表当前时间，HEAD^代表上一个时间点，HEAD~100代表是现在到过去的第一百个时间点。 git reset –hard blc588blc588代表commit id。 使用第二条命令的效果： 123456xxx:~/workplace/demo$ sudo git reset --hard b1c588HEAD 现在位于 b1c5887 first addxxx:~/workplace/demo$ cat readme.txtGit is a version control tool.Git is so nice.this is first add something to readme. 回到未来 这个只能使用commit id来进行操作，如果不知道commit id,可以试用git reflog来查看。123456789101112xxx:~/workplace/demo$ git reflogb1c5887 HEAD@&#123;0&#125;: reset: moving to b1c588fac4c98 HEAD@&#123;1&#125;: commit: second addb1c5887 HEAD@&#123;2&#125;: commit: first add435eb64 HEAD@&#123;3&#125;: commit (initial): readme.txtxxx:~/workplace/demo$ sudo git reset --hard fac4c98HEAD 现在位于 fac4c98 second addxxx:~/workplace/demo$ cat readme.txtGit is a version control tool.Git is so nice.this is first add something to readme.this is second add something to readme.]]></content>
  </entry>
  <entry>
    <title><![CDATA[flask-web的思维导图]]></title>
    <url>%2F2018%2F05%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[简单展示flask-web的框架，后面会用详细的文章来阐述这幅图。 Quick Start]]></content>
  </entry>
</search>
