<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统的主要功能]]></title>
    <url>%2F2018%2F06%2F01%2Fos-process-1%2F</url>
    <content type="text"><![CDATA[处理机管理功能 在传统的多道程序系统中，处理机的分配和运行都是以进程为基本单位，因而对处理机的管理可归结为对进程的管理；在引入线程的OS中，也包含对线程的管理。处理机管理的主要功能是创建和撤销进程（线程），对诸进程（线程）的运行进行协调，实现进程（线程）之间的信息交换，以及按照一定的算法把处理及分配给进程。 1.进程控制 为作业创建进程，撤销已经结束的进程，以及控制进程在运行过程中的状态转换，同样，它也应该具有对线程进行类似操作的能力。 2.进程同步 多个进程想要使结果具有可再现性，应该对进程进行同步控制。 通常采用进程互斥和进程同步来实现该功能 3.进程通信4.进程调度 作业调度和进程调度 存储器管理功能设备管理功能文件管理功能]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-进程]]></title>
    <url>%2F2018%2F05%2F30%2Fos-process%2F</url>
    <content type="text"><![CDATA[进程进程是正在执行程序的实例，包括程序计算机，寄存器和变量。 从概念上说，每个进程都有自己的虚拟CPU，当然，实际的CPU是在进程之间来回切换。 实际上，只有一个物理程序计数器，所以在每个程序运行时，它的逻辑程序计数器被装入到实际的程序计数器中。当该程序执行结束（暂停）时，物理程序计数器被装入到逻辑程序计数器中。 守护进程unix中，可以通过一个系统调用来创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用fork后，这两个进程（父进程和子进程）拥有相同的内存映像，同样的环境字符串和同样的打开文件 写时复制：进程的状态： 运行：cpu和条件都满足 阻塞：cpu满足，必要条件不满足 就绪：cpu不满足，必要条件满足 进程控制块（PCB）–进程存在的唯一标志 PCB记录了操作系统所需的、用于描述进程的当前情况以及控制进程运行的全部信息。操作系统是根据PCB对进程进行控制和管理的。（1）当OS要调度某进程执行时，要从该进程的PCB中查出其现行状态及优先级。（2）调度到某进程后，根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据PCB中的程序和数据的内存始址，找到其程序和数据。（3）进程载执行过程中，与其他进程的通信，同步都需要用到PCB（4）当进程切换时，处理机环境也保存在PCB中 进程的实现： 有了进程模型，进程应该如何实现 为了实现进程模型，操作系统维护者一张（一个数据结构），即进程表。每个进程占用 一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针，内存 分配状况、所打开文件的状态、帐号和调度信息，以及其他在进程进行状态转换时所必 须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。 中断向量在进程切换中的重要作用单个CPU如何维护多个顺序进程假设当一个磁盘中断发生时，用户进程正在运行，则中断硬件将程序计数器，程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这些是硬件完成的所有操作，然后软件，特别是中断服务例程就接管了一切剩余的工作。 线程为什么需要多线程1.有了多线程，并行实体拥有共享同一个地址空间和所有可有数据的能力。2.线程比进程更轻量级。3.IO密集的处理，使用多线程效率更高。 线程概念试图实现的是，共享一组资源的多个进程的执行能力，以便这些线程可以为完成某一个任务而共同工作。 进程：用某种方法将相关的资源集中在一起。进程有存放程序正文和数据以及其他的资源的地址空间。这些资源包括打开的文件，子进程，即将发生的定时器、信号处理程序、帐号信息等。线程：CPU调度的单位 线程堆栈线程的问题线程的过程子进程和父进程可以拥有相同的多线程吗，如果解决两者中线程的同步多线程中共享数据的同步 POSIX线程为了实现可移植的线程程序，IEEE定义了线程的标准。它定义的线程包叫作pthread.大部分UNIX系统都支持该标准。pthread_create 创建一个新的线程pthread_exit 结束调用的线程pthread_join 等待一个特定的线程退出pthread_yield 释放CPU来运行另外一个线程pthread_attr_init 创建并初始化一个线程的属性结构pthread_attr_destroy 删除一个线程的属性结构 代码演示：12345678910111213141516171819202122232425#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUMBER_OF_THREADS 10void *print_hello_world(void *tid)&#123; printf(&quot;hello world,Greeting form thread %d\n&quot;, tid); pthread_exit(NULL);&#125;int main(int args,char *argv[])&#123; pthread_t threads[NUMBER_OF_THREADS]; int status,i; for(i=0;i&lt;NUMBER_OF_THREADS; i++)&#123; printf(&quot;main here,creating thread %d\n&quot;,i); status = pthread_create(&amp;threads[i],NULL,print_hello_world,(void*)i); if(status!=0)&#123; printf(&quot;oops,pthread_create returned error code %d\n&quot;, status); &#125; &#125; exit(NULL);&#125; output:1234567891011121314151617181920main here,creating thread 0main here,creating thread 1hello world,Greeting form thread 0hello world,Greeting form thread 1main here,creating thread 2main here,creating thread 3hello world,Greeting form thread 2main here,creating thread 4hello world,Greeting form thread 3main here,creating thread 5hello world,Greeting form thread 4main here,creating thread 6hello world,Greeting form thread 5main here,creating thread 7hello world,Greeting form thread 6main here,creating thread 8hello world,Greeting form thread 7main here,creating thread 9hello world,Greeting form thread 8hello world,Greeting form thread 9 线程的实现方式 线程已经在许多系统中实现了，但各系统的实现方式并不完全相同。在有的系统中所实现的是用户级线程（ULT），而另一些系统所实现的是内核支持线程（KST），还有的系统是混合实现。 什么是用户级线程 用户级线程仅存在于用户空间中，对于这种线程的创建、撤销、线程之间的同步与通信等功能，同无需利用系统调用来实现。对于用户级线程的切换，也无须内核的支持。对于设置用户级线程的系统，其调度仍是以进程为单位进行的，内核完全不知道用户级线程的存在。 在用户空间管理线程时，每个进程都需要有其专用的线程表，用来跟踪该进程中的线程。线程表和进程表相似，不过它记录的仅仅是各个线程的属性，比如每个线程的程序计数器、堆栈指针、寄存器和状态等。该线程表由运行时系统管理。 什么是内核支持线程 对于通常的进程，无论是系统进程还是用户进程，进程的创建、撤销、以及要求由系统设备完成的I/O操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成。进程的切换同样是在内核的支持下实现的。不论什么进程，它们都是在操作系统内核的支持下运行的，是与内核紧密相关的。 这里所谓的内核支持线程KST（kernel supported threads）,也都同样是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤销和切换等也是依靠内核，在内核空间实现的。此外，在内核空间还为每一个内核支持线程设置了一个线程控制块，内核是根据该控制块而感知某线程的存在，并对其加以控制。 内核支持线程有以下的优点： （1）内核中拥有每个线程的线程控制块，那么内核就可以使用调度算法来调度进程中多个线程并发执行。 （2）如果进程中的一个线程被阻塞了，内核可以调度该进程中的其他线程占用处理器运行，也可以运行其他进程中的线程。 （3）内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小。 （4）内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。内核线程的缺点也很明显，对于用户线程的切换，要从用户态进行到内核态。 线程切换线程切换 用户级线程为什么要和内核级线程进行映射，映射的模型线程的实现 不论是进程还是线程，都必须直接或间接地取得内核的支持。由于内核支持线程可以直接利用系统调用为它服务，故线程的控制相当简单；而用户级线程必须借助于某种形式的中间系统的帮助方能取得内核的服务，故在对线程的控制上要稍复杂些。 内核支持线程的实现 在仅设置了内核支持线程的OS中，一个可能的线程控制方法是，系统在创建一个新进程时，便为它分配一个任务数据区PTDA（per task data area），其中包括若干线程控制块TCB空间。在每一个TCB中可保存线程标识符，优先级，线程运行的CPU状态等信息。虽然这些信息与用户线程TCB中的信息相同，但现在却是被保存在内核空间中。 每当进程要创建一个线程时，便为新线程分配一个TCB，将有关信息填入该TCB中，并为之分配必要的资源，如为线程分配数百至数千的栈空间和局部变量存储区。 用户级线程的实现 用户级线程是在用户空间实现的。所有的用户级线程都具有相同的结构，它们都运行在一个中间系统的上面。当前有两种方式实现的中间系统，即运行时系统和内核控制线程。（1）所谓“运行时系统”，实质上是用于管理和控制线程的函数（过程）的集合，其中包括用于创建和撤销线程的函数、线程同步和通信的函数以及实现线程调度的函数等。正因为有这些函数，才能使得用户线程和内核无关。运行时系统中的所有函数都驻留载用户空间，并作为用户级线程和内核之间的接口. 在传统的OS中，进程在切换时必须先由用户态转为核心态，再由核心来执行任务；而用户级线程在切换时则不需要转入核心态，而是由运行时系统的线程切换过程来执行切换任务。该过程将线程的CPU状态保存在该线程的堆栈中，然后按照一定的算法选择一个处于就绪状态的新线程进行运行，将新线程堆栈中的CPU状态装入到CPU相应的寄存器中;一旦将栈指针和程序计数器切换后，便开始了新线程的运行。由于用于级线程的切换无需进入内核，且切换操作简单，因为使用用户级线程的切换速度非常快。不管在传统的OS中，还是在多线程OS中，系统资源都是由内核管理的。在传统的OS中，进程是利用OS提供的系统调用来请求系统资源的，系统调用通过软中断机制进入OS内核，由内核来完成相应资源的分配。用户级线程是不能利用系统调用的。当线程需要系统资源时，是将该要求传送给运行时系统，由后者通过相应的系统调用来获得系统资源的。 （2）内核控制线程 这种线程又称为轻型进程LWP（light-weight process）。每一个进程都可拥有多个LWP，同用户级线程一样，每个LWP也有自己的TCB。LWP可通过系统调用来获得内核提供的服务，这样，当一个用户级线程运行时，只要将它链接到一个LWP上，此时它便具有了内核线程的所有属性。 LWP线程是有限的，所有用户线程可以复用这些LWP。如果需要与内核通信，则需要和LWP进行连接。这样，通过LWP可把用户级线程和内核线程链接起来，用户级线程可通过LWP来访问内核。从内核的角度来看，它只能意识到LWP的存在，而意识不到用户级线程的存在。这种方式也是实现了用户级线程和内核无关。 当用户级线程不需要与内核通信时，并不需要LWP；而当要通信时，便需要借助于LWP，而且每个要通信的用户级线程都需要一个LWP。如果要通信的用户级线程大于LWP的数量，那么就需要有用户级线程等待。 在内核线程执行操作时，如果发生阻塞，那么与之相连的LWP也会阻塞，进而连接到LWP上的用户级线程也会被阻塞。如果进程只有一个LWP，那么和传统的OS一样，当进程执行系统调用时，该进程实际上是阻塞的。但如果一个进程中含有多个LWP，一个LWP阻塞，进程中的其他LWP可以执行;即使进程中的所有LWP全部不阻塞，进程中的线程也仍然能继续执行，只是不能再去访问内核。 用户级线程和内核控制线程（LWP）的连接（1）一对一模型 该模型为每一个用户线程都设置一个内核控制线程与之相连，当一个线程阻塞时，允许调度另一个线程运行。在多处理及系统中，则有多个线程并行执行。 该模型并行能力强，但每创建一个用户线程相应地就需要创建一个内核线程，开销较大，需限制整个系统的线程数。win2000,winNT,OS/2实现该模型。（2）多对一模型 该模型将多个用户线程映射到一个内核控制线程，为了管理方便，这些用户线程一般属于一个进程。运行在该进程的用户空间，对这些线程的调度和管理也是在该进程的用户空间中完成。当用户需要访问内核时，才将其映射到一个内核控制线程上，但每次只允许一个线程进程映射。 该模型的主要优点是开销小，效率高，但当一个线程在访问内核时发生阻塞，则整个进程都会被阻塞，而且多处理机系统中，一个进程的多个线程无法实现并行。（3）多对多模型 该模型结合以上两种模型的优点，将多个用户线程映射到多个内核控制线程，内核控制线程的数目可以根据应用和系统的不同而变化。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git学习（二）]]></title>
    <url>%2F2018%2F05%2F22%2Fgit-learning-2%2F</url>
    <content type="text"><![CDATA[工作区和暂存区 git设计中有一些概念，了解这些概念对于深入学习git有很大的帮助。其中就有工作区和暂存区。 工作区 工作区就是创建的工作目录，这个目录下的所有文件都需要在git的管理之下。文件的创建，修改，删除都会被git记录。 暂存区 另外一个就是.git。这个称为版本库。版本库里存了很多东西，其中一个就是暂存区，所有的修改只有在提交到暂存区，才能被commit。12345678910位于分支 master要提交的变更： （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存） 修改： readme.txt未跟踪的文件: （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容） LICENSE git add 是将文件修改添加到暂存区 git commit 是将暂存区的所有内存提交到当前分支上 管理修改 上一节提到暂存区和工作区，git管理的是修改，而不是文件文件。为什么这样说呢，实验一下。 原readme.txt中的内容： 12git is a version control toolgit is so nice 第一次修改后的内容： 123git is a version control toolgit is so nicethis is first test 使用命令： 123456789101112xxx:~/workplace/demo$ git add readme.txtxxx:~/workplace/demo$ sudo git commit -m &quot;first&quot;[master e76954f] first1 file changed, 3 insertions(+)create mode 100644 readme.txtxxx:~/workplace/demo$ git status位于分支 master无文件要提交，干净的工作区xxx:~/workplace/demo$ cat readme.txtgit is a version control toolgit is so nicethis is first test 第二次修改的内容： 1234git is a version control toolgit is so nicethis is first testthis is second test 使用一下命令： 123456789 xxx:~/workplace/demo$ sudo git commit -m &quot;test&quot; 位于分支 master 尚未暂存以备提交的变更： （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容） （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动） 修改： readme.txt修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;） 由上面执行结果可以，第二次的修改并未被提交。 这也说明，只有将修改添加到暂存区才能进行后一步的提交。也能看出来git的确是对修改进行管理的，只有当修改添加到暂存区，才能把修改提交到分支上。文件已经被修改了，但是并不会被提交。 撤销修改 上一次讲过git的时光魔法，利用git reset可以让文件回到某一状态。但是针对的是提交后的。每次reset的标记也是commit id。 还有一种状况需要考虑，就是在修改没有commit之前，如何让文件恢复到某一时刻的状态。 git checkout就是专门负责则这个功能的。 1234567891011xxx:~/workplace/demo$ cat readme.txtgit is a version control toolgit is so nicethis is first testthis is second testthis is modify.xxx:~/workplace/demo$ git checkout readme.txtxxx:~/workplace/demo$ cat readme.txtgit is a version control toolgit is so nicethis is first test 可以从上面的命令清楚的看到，git checkout命令就相当于撤回键一样，可以让修该回到之前的一个状态。还有一个需要考虑的是，如果你的修改已经被提交，那么需要使用reset来回到上一个状态。 删除修改12345xxx:~/workplace/demo$ rm readme.txtxxx:~/workplace/demo$ sudo git commit -m &quot;delete&quot;[master 94de890] delete 1 file changed, 1 insertion(+)xxx:~/workplace/demo$]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git学习（一）]]></title>
    <url>%2F2018%2F05%2F22%2Fgit-learning-1%2F</url>
    <content type="text"><![CDATA[git是什么 git是一种版本控制工具，它的诞生是因为linux日益增长，代码合并依靠手工已经非常吃力。一开始linux也是用的其他的版本控制工具，但是后来提供版本控制的公司不再向linux社区提供支持，原因是因为这些大神太有创造性了，要修改他们的代码…balabala。最后linux的核心人物linus带领自己的小伙伴自己编写了一个版本控制工具：git.大神是怎么炼成的，心中充满了羡慕。 git能做什么 之前也没用到版本控制工具，只是在上一个项目中接触一点。但是也没系统的学习，刚好又要用到版本控制工具，就详细的学习一下。这么牛的东西不学习一下，怎么装x呢。 其实以前自己一个人做项目没有什么感受，但是几个人共同完成一个项目，问题就会层出不穷。比如jar包版本不同啊，这个可以通过项目管理工具maven来解决，什么是maven，有时间另写一遍来介绍它。还有一个比较大的问题，就是几个人的文件如何保持一致，一开始大家都是同一个文件没什么问题。但是任务一开始就是完全不同的场景了，A开始写他的功能，B开始写他的测试，C开始写他的页面。最后如何让大家的文件汇总起来呢，总不能一直复制粘帖吧，这样的效率是惨不忍睹的。git或者其他的版本控制工具可以帮助我们解决这个问题，具体怎么解决，一步一步学习吧。 git怎么用git的安装 在ubuntu环境： 1sudo apt-get install git 查看是否安装成功： 12git --versiongit version 2.7.4 git初次尝试 先创建一个文件夹作为git的工作目录， 1mkdir demo 什么意思呢?其实这个工作目录在git中有个专门的名称，叫做仓库，英文repository.它的意思这个目录下的所有文件都可以被git管理，每个的创建，修改，删除，git都能知道。git记录这些事情的发生，所以它也可以追踪到在整个文件的历史，并且它可以使某个文件回到某个历史节点。 刚刚只是创建了一个目录，还没有和git取得关联，这时候git并不能管理整个文件夹。 使用以下命令： 12cd demogit init 初始化空的 Git 仓库于 /home/xxx/workplace/demo/.git/ 这时候demo目录就变成了git可以管理的仓库了。 现在仓库下创建一个文件 touch readme.txt 在该文件里写入以下内容： 1234Git is a version control tool.Git is so nice.使用：git add readme.txt 可以将修改后的文件提交到暂存区内。12345位于分支 master初始提交要提交的变更： （使用 &quot;git rm --cached &lt;文件&gt;...&quot; 以取消暂存） 新文件： readme.txt 使用： 1git commit -m &quot;readme.txt&quot; 可以将暂存区的内容都提交到本地仓库中。（根提交） 435eb64] readme.txt12 1 file changed, 2 insertions(+)create mode 100644 readme.txt git的魔法–穿越时空 在表演git的魔法之前，我们先为文件做一个时间线，这样对一个文件才能完成穿越时空的操作。 1.在readme.txt中写入 1this is first add someting to readme.txt 然后输入命令 12git add readme.txtgit commit -m &apos;first add&apos; 2.在readme.txt中写入 1this is second add someting to readme.txt 然后输入命令 12git add readme.txtgit commit -m &apos;second add&apos; 使用git log 来查看历史线。1234567891011121314151617 commit fac4c988c2e9dc06074355cd137b51319ed65a7fAuthor: learner66 &lt;2952184251@qq.com&gt;Date: Tue May 22 19:01:07 2018 +0800 second addcommit b1c5887736de9909de4643ddd06a84b70ab50394Author: learner66 &lt;2952184251@qq.com&gt;Date: Tue May 22 19:00:17 2018 +0800 first addcommit 435eb64ac7e2b5f0d2f8153d940fc1d2ff92b89bAuthor: learner66 &lt;2952184251@qq.com&gt;Date: Tue May 22 18:50:46 2018 +0800 readme.txt readme.txt1234Git is a version control tool.Git is so nice.this is first add something to readme.this is second add something to readme. 穿越到过去 已经知道了这条历史线，git可以任意的穿越到过去的某个时间点。 回到过去有两种方法 git reset –hard HEAD^HEAD代表当前时间，HEAD^代表上一个时间点，HEAD~100代表是现在到过去的第一百个时间点。 git reset –hard blc588blc588代表commit id。 使用第二条命令的效果： 123456xxx:~/workplace/demo$ sudo git reset --hard b1c588HEAD 现在位于 b1c5887 first addxxx:~/workplace/demo$ cat readme.txtGit is a version control tool.Git is so nice.this is first add something to readme. 回到未来 这个只能使用commit id来进行操作，如果不知道commit id,可以试用git reflog来查看。123456789101112xxx:~/workplace/demo$ git reflogb1c5887 HEAD@&#123;0&#125;: reset: moving to b1c588fac4c98 HEAD@&#123;1&#125;: commit: second addb1c5887 HEAD@&#123;2&#125;: commit: first add435eb64 HEAD@&#123;3&#125;: commit (initial): readme.txtxxx:~/workplace/demo$ sudo git reset --hard fac4c98HEAD 现在位于 fac4c98 second addxxx:~/workplace/demo$ cat readme.txtGit is a version control tool.Git is so nice.this is first add something to readme.this is second add something to readme.]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[flask-web的思维导图]]></title>
    <url>%2F2018%2F05%2F20%2Fflask-web%2F</url>
    <content type="text"><![CDATA[简单展示flask-web的框架，后面会用详细的文章来阐述这幅图。 Quick Start]]></content>
      <categories>
        <category>flask-web</category>
      </categories>
  </entry>
</search>
